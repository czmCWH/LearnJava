# 一、登录实现功能
案例：输入用户名 和 密码进行登录。
请求：`POST /login`、`application/json`

三层架构实现：

    Controller 层：
    1、接收请求参数（json）
    2、调用 Service 方法
    3、响应结果
    
    Service 层：
    1、调用 Mapper 接口查询员工信息；
    2、查询成功，返回登录信息；
    
    Mapper 层：
    1、select * from emp where username = 'zhangsan' and password = '123456';


问题：用户在没有登录的情况下，依然可以访问数据库中所有信息。
解决：在所有请求之前加 登录校验。

# 二、登录校验
问题：每个 Http 请求是无状态的、相互独立的，因此就算用户调用了 普通登录接口成功，后续的接口也不知道是否登录过。
解决：使用登录校验思想，如下核心概念：

> 登录标记：用户登录成功之后，在后续的每一次请求中，都可以获取到该标记。【会话技术】
>
> 统一拦截技术：过滤器 Filter、拦截器 Interceptor


## 1、会话技术

### 会话：

    用户打开测览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束（即浏览器与服务器之间的请求交互）。

    在一次会话中可以包含多次请求和响应。

### 会话跟踪： 

    一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间**共享数据**。

## 2、会话跟踪技术
1、`Cookie` 客户端会话跟踪技术：`Cookie` 的所有数据存储在浏览器。
2、`Session` 服务端会话跟踪技术：所有数据存储在服务端。
3、令牌技术（常用）


# 三、Cookie 客户端会话跟踪技术
1、优点：HTTP协议中支持的技术。
2、缺点：
移动端APP无法使用，因为 Cookie 数据存储在浏览器中；
Cookie不安全，用户可以自己禁用Cookie。用户可以通过浏览器禁用 Cookie；
Cookie不能跨域；

# 四、Session 服务端会话跟踪技术
Session 服务端会话跟踪技术：本质也是 `Cookie`。

1、优点：Session 值存储在服务端，安全；
2、缺点:
服务器集群环境下无法直接使用 session；
它有 Cookie 所有的缺点；

# 五、令牌技术（常用）
令牌：是指后端加密的字符串，用于返回给前端请求时携带。
令牌技术优点：
1、支持所有端（PC、移动端）；
2、解决集群环境下的认证问题；
3、减轻服务器端存储压力；

## 六、JWT 令牌
令牌技术有很多种，`JWT`是令牌技术的一种，全称: `JS0N Web Token` https://jwt.io/。
`JWT` 令牌定义了一种简洁的、自包含的格式，用于在通信双方以 `json` 数据格式安全的传输信息。
`JWT`分为3部分：
第一部分：`Header` (头)，记录令牌类型、签名算法等。 例如：`{"alg":"HS256","type":"JWT"}`
第二部分：`Payload`(有效载荷)，携带一些自定义信息、默认信息等。 例如：`{"id":"1","username":"Tom"}`
第三部分：`Signature`(签名)，防止 `Token` 被篡改、确保安全性。将 `header、payload` 融入，并加入指定秘钥，通过指定签名算
法计算而来。

> `Base64`：是一种基于64个可打印字符(`A-Z a-z 0-9 + /`)来表示二进制数据的编码方式。

### 实现方式：
1、导入依赖；
```xml
<!--   JWT 令牌依赖     -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>0.12.3</version>
        </dependency>
```
2、生成JWT令牌；

```java
@Test
void testGenerateJwt() {
    // 自定义信息
    Map<String, Object> claims = new HashMap<>();
    claims.put("id", 1);
    claims.put("username", "czm");


    SecureRandom secureRandom = new SecureRandom();
    byte[] randomBytes = new byte[32]; // 256 bits = 32 bytes
    secureRandom.nextBytes(randomBytes);

    String randomString = Base64.getEncoder().encodeToString(randomBytes);

    // 生成 jwt 令牌
    String jwt = Jwts.builder()
            .signWith(SignatureAlgorithm.HS256, randomString)
            .addClaims(claims)
            .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24))
            .compact();

    System.out.println("---jwt = " + jwt);
}
```

生成的令牌可以复制到官网 https://jwt.io/ 查看详细信息。



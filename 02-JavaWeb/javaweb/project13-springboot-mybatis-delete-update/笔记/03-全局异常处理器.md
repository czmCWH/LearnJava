# 全局异常处理器

`SpringBoot` 项目代码执行： `Controller 层 -> Service 层 -> Mapper 层`。
如果 `Mapper 层` 执行时抛出了 `Exception`，开发者并没对此异常处理，异常会向上传递，如下所示：
`Mapper 层 -> Service 层 -> Controller 层 -> JavaJVM`。
最终 JavaJVM 会返回一个可读性不好的错误信息给前端。

那么出现异常该如何处理呢？

## 方法1：
在所有的 Controller 的所有方法中 try-catch 业务代码的异常，然后做处理异常响应，给前端友好的提示。
问题：代码臃肿，不推荐！！！

## 方法2: 全局异常处理器 ⚠️⚠️⚠️
使用 `@RestControllerAdvice + @ExceptionHandler` 注解 定义一个 全局异常处理器 统一处理 Controller 层的异常。
优点：简洁、优雅、推荐。
实现：`GlobalExceptionHandler.java`

```java
/*
 * 定义一个全局异常处理器
 *   @RestControllerAdvice 注解，用于全局性地处理控制器（Controller）层的异常；
 *   @RestControllerAdvice == @ControllerAdvice + @ResponseBody；
 *   @ResponseBody 用于把方法返回值自动序列化为 JSON/XML
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * @ExceptionHandler 注解，集中处理特定异常
     * @param ex 表示拦截什么类型的异常。Exception，表示拦截所有类型的异常
     * @return 返回值表示处理异常后，返回给前端的响应结果
     */
    @ExceptionHandler   //
    public Result doException(Exception ex) {
        log.info("--- 全局异常信息 = {}", ex.getMessage());
        return Result.error("出错了，请联系管理员！");
    }

    /**
     * 指定捕获 DuplicateKeyException 异常
     * @ExceptionHandler 会按照异常的继承关系，从下往上查询异常处理方法进行处理
     */
    @ExceptionHandler(value = DuplicateKeyException.class)
    public Result doDuplicateKeyException(DuplicateKeyException ex) {
        log.info("--- 重复key异常 = {}", ex.getMessage());
        // 获取异常的信息并解析，反馈更精确的信息给前端
        String message = ex.getMessage();
        int i = message.indexOf("Duplicate entry");
        String errMsg = message.substring(i);
        String[] arr = errMsg.split(" ");
        return Result.error(arr[2] + "已存在");
    }
}
```

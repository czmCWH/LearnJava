# 一、案例：员工信息列表分页查询
1、案例：以分页的形式查询员工数据，包含：员工基本信息、所在部门名称。

2、数据准备：请以 `/笔记/sql/` 下的语句，依次创建表: `dept emp emp_expr`，并填充数据

3、前后端数据交互：
  前端传递给后端的分页参数：
     page，页码；
     pageSize，每页展示记录数；
  后端返回的数据：
     List rows，数据列表；
     Long total，总记录数；

4、案例实现：需要2条sql，如下所示：
步骤1，查询每页数据的 员工信息、部门名称 --- 前端渲染表格数据
```sql
-- limit 起始索引 每页条数;
-- 查询第1页：limit 0, 10;
-- 查询第2页：limit 10, 10;
-- 查询第3页：limit 20, 10;
-- 起始索引 = (页码 - 1) * 每页记录数
select e.*, d.name from emp e left join dept d on e.dept_id = d.id limit 0, 10;
```
步骤2，查询总记录数 --- 前端渲染分页条
```sql
select count(*) from emp left join dept on emp.dept_id = dept.id;
```

5、三层架构各层职责
* Controller 层
  1、接收参数（分页、条件）
  2、调用 Service 层，进行分页查询，获取PageBean
  3、响应结果

* Service 层
  1、使用 PageHelper 完成分页条件查询
  2、封装 PageBean 对象返回

* Mapper 层
  使用 Mybatis 进行sql查询


# 二、PageHelper 插件 简化 Mybatis 分页查询
`PageHelper` 是第三方提供的在 `Mybatis` 框架中用来实现分页的插件，用来简化分页操作，提高开发效率。

PageHelper 使用步骤：

* 步骤1、引入 PageHelper 的依赖：
```xml
<dependency>
	<groupId>com.github.pagehelper</groupId>
	<artifactId>pagehelper-spring-boot-starter</artifactId>
	<version>1.4.7</version>
</dependency>
```

* 步骤2、定义 Mapper 接口的查询方法：
注意：使用 PageHelper 进行分页查询时，不需要考虑 sql 中任何分页相关的操作，只需要定义一个简单的sql接口。如下代码所示：
```java
@Select("select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id")
List<Emp> spPage();
```

* 步骤3、在 Service 方法中实现分页查询；
```java
@Override
public PageBean spPage(Integer page, Integer pageSize) {
     // 1、设置 PageHelper 的分页参数，PageHelper 会自动完成分页操作
     PageHelper.startPage(page, pageSize);
    
     // 2、调用mapper 中的查询方法
     List<Emp> empList = empMapper.spPage();
    
     // 3、解析查询结果
     // PageHelper 插件会将分页查询的结果封装到 Page<T> 分页查询结果对象中，T 表示分页查询结果记录数据的泛型
     Page<Emp> p = (Page<Emp>) empList;   // 强转，Page 继承自 ArrayList
    
     // ⚠️：如果有其它分页sql，需要再写一次  PageHelper.startPage(page, pageSize);，再写对应的sql。
    
     // 4、封装返回对象
     return new PageBean<Emp>(p.getTotal(), p.getResult());
}
```

## PageHelper 使用规范 ⚠️
1、在 Mapper 层，sql 语句中不需要考虑分页，不需要使用 limit，只需普通的list查询即可；并且不需要考虑 count聚合函数 获取总记录数 total;
2、在 Mapper 层，在使用 PageHelper 插件的 sql 语句末尾不能加 ;(分号)，其它情况可以加分号；
3、在 Service 层，`PageHelper.startPage(page, pageSize);` 只会对紧跟在其后的第一条SQL语句进行分页处理，是一一对应关系。其后的分页sql需要再次写；



# 三、多条件分页查询 - 动态 sql
1、需求：根据多个动态条件（name、gender、begin、end）来查询员工基本信息 和 所在部门名称，并以分页的形式查询员工数据。

2、代码实现分析：进行多条件分页查询时，使用 Mybatis 使用 XML 方式实现 动态 SQL 来查询。

3、原始sql实现：
```mysql
 select e.*, d.name deptName
        from emp e
                 left join dept d on e.dept_id = d.id
        where e.name like '%李%'
            and e.gender = 1
            and e.entry_date between '2020-01-01' and '2035-01-01'
        order by e.update_time desc;
```


## 3.1、Mybatis 构建模糊匹配条件注意事项 ⚠️

使用 Mybatis 执行的带参数的 sql：
```mysql
 select e.*, d.name deptName
        from emp e
                 left join dept d on e.dept_id = d.id
#         where e.name like '%#{name}%'   ❌！
        where e.name like concat('%', #{name}, '%')
            and e.gender = #{gender}
            and e.entry_date between #{begin} and #{end}
        order by e.update_time desc
```

由于 Mybatis 无法识别引号内的参数占位符（如：`'#{}' 或 '${}'`），所以 `where e.name like '%#{name}%'` 中的参数无法正确替换！

原因：Mybatis 对sql语句中 `like '%#{name}%'` 编译后为 `like '%?%'`，由于 ? 在引号内，Mybatis 是无法识别为参数占位符，因此无法进行参数值替换。
解决办法： 通过 sql语句的 `concat` 函数实现字符串的拼接： `like concat('%', #{name}, '%')`。


## 3.2、Mybatis 基于XML开发实现 动态SQL ⚠️
1、为什么使用 动态SQL？
由于业务场景中，name、gender、begin和end 查询条件是随着用户输入的变化而变化的，即可能存在或不存在。
EmpMapper0.xml 中定义 SQL 的这些查询参数是写死的，如果参数变化会导致SQL执行异常！因此需要借助 动态SQL解决此问题。

2、什么是 动态SQL
- 随着用户的输入或外部条件的变化而变化的SQL语句，我们称为 动态SQL。
- Mybatis 基于XML实现 动态SQL

动态SQL 常用标签：
```xml
<if> 标签：判断条件是否成立，如果条件为true，则拼接SQL语句。
 
<where> 标签：
  根据查询条件来生成 where 关键字，例如：如果条件都不存在，则 sql 语句中不添加 where。
  自动去除掉 where 内查询条件前面多余的 `and`、或 `or`；如：如果 name 为 null，则 gender 前面 and 会被去掉

<set> 标签：用于动态生成 update 语句中的 set 子句。会自动剔除最后一个字段末尾多余的逗号，避免语法错误！
```

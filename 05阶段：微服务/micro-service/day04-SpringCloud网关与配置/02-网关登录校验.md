# 一、网关登录校验
问题：在 `hmall` 微服务项目中，我们把 登录授权 功能放在 `user-service` 中。当其它模块中需要通过 token 获取到登录用户信息时，就需要做 JWT 令牌校验。
如果在其它服务中都添加 JWT 令牌校验代码，会造成代码重复、密钥泄漏的风险。这样做就不合适。

解决思路：可以把 JWT 令牌校验 放在 网关服务中，然后把用户信息传递到其它服务，这就需要在 网关转发之前做 JWT 令牌校验。

面临问题：
* 1、如何在网关转发请求之前做登录校验？ 解决：使用自定义网关过滤器，在过滤器中做登录校验。
* 2、网关如何将用户信息传递给微服务？ 解决：在过滤器中登录校验完获取到 token 后，保存到请求头，再转发到微服务。
* 3、如何在微服务之间传递用户信息？ 解决：微服务之间通过 OpenFeign 发送请求时，保存用户到请求头再进行发送请求。

网关将请求转发到微服务之前做JWT校验

## 1、自定义网关过滤器
网关过滤器有两种，分别是:

### GatewayFilter

`GatewayFilter`：路由过滤器，作用于任意指定的路由；默认不生效，需要要在 `application.yaml` 配置到路由后对配置的路由生效。
即，在 配置路由规则 中通过 `filters` 或者 ` default-filters` 属性配置的过滤器，如下配置所示，Spring 一共提供了33种。开发者也可以自定义，会比较麻烦。
```.yaml
spring:
    gateway:
      routes:
        - id: item-service
          uri: lb://item-service
          # 使用 AddRequestHeader 过滤器，给进入 item-service 服务的所有请求添加请求头 X-Request-Color：blue
          filters:
            - AddRequestHeader=X-Request-Color, blue
      # default-filters 给网关中的每一个服务请求添加请求头： X-Truth:any will be rich
      default-filters:
        - AddRequestHeader=X-Truth, any will be rich
```

如需自定义 `GatewayFilter` 请学习 <https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=f97692c2f656607aeb97ee92b4310d9e&p=63>

### GlobalFilter（常用）
`GlobalFilter`：全局过滤器，作用范围是所有路由；声明后自动生效。自定义 `GlobalFilter` 需实现 `GlobalFilter` 接口，如下代码所示：

```java
/**
 * 网关过滤器，用于用户登录校验
 */

@Component
public class MyGlobalFilter implements GlobalFilter, Ordered {

    /**
     * filter 方法是过滤器逻辑的核心方法
     *
     * @param exchange 请求上下文。包含整个过滤器链内共享数据，例如：request、response 等。
     * @param chain 过滤器链。当前过滤器执行完后，要调用过滤器链种的下一个过滤器。
     * @return 表示一个回调函数，等转发到服务接收请求处理完返回后，再调用该回调函数。
     */
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // TODO 模拟登录校验逻辑
        // 1、获取请求
        ServerHttpRequest request = exchange.getRequest();
        // 2、处理过滤器业务
        HttpHeaders headers = request.getHeaders();
        System.out.println("---- 网关 headers ----" + headers);
        // 3、放行请求，请求会依次进入过滤器链
        return chain.filter(exchange);
    }

    // 返回过滤器执行优先级，值越小，优先级越高
    @Override
    public int getOrder() {
        /*
         网关在进行路由转发过程中，最后执行的一个过滤器是 NettyRoutingFilter。因此需要保证我们自定义的过滤器在 NettyRoutingFilter 之前执行。
         通过实现 Ordered 接口来指定自定义过滤器的执行顺序，getOrder 返回值越小越先执行。
         NettyRoutingFilter 的优先级为 Int 类型的最大值，此处返回 0 比它小，这样 MyGlobalFilter 会先执行。
         */
        return 0;
    }
}
```

> 注意：
> 1、以上两种自定义过滤器的过滤方法签名完全一致，即过滤器的核心方法 `filter` 完全一致。
> 2、自定义 GatewayFilter 比较麻烦，开发中都是自定义 GlobalFilter；


## 2、网关过滤器实现登录校验
`hmall` 是基于 `JWT` 实现的登录校验，目前相关功能在 `hm-service` 模块。我们可以将其中的 JWT 工具拷贝到 `gateway 模块`，然后基于 `GlobalFilter` 来实现登录校验。

> 代码实现：`hm-gateway 模块， /filters/AuthGlobalFilter.java`


## 3、网关传递用户信息到微服务
上面通过 网关过滤器 实现了登录校验功能，拿到了登录用户的信息，通过将 用户信息保存到请求头 传递到下游的每个微服务，每个微服务中都需要从请求头里获取用户信息来实现自己的逻辑。
* 问题：每个微服务中的业务可能会很多，这样获取请求头用户信息的逻辑需要在每一个业务中都写一次 ？
* 解决：在微服务中每个业务接口执行之前来获取请求头用户信息 --- Spring MVC 拦截器 中获取用户信息，并保存到 ThreadLocal 中。

### 步骤一、在网关的登录校验过滤器中，把获取到的用户信息写入请求头
需求：修改 `gateway 模块` 中的登录校验过滤器，在校验成功后保存用户到下游请求的请求头中。

代码实现如下所示，要修改转发到微服务的请求头，需要用到 ServerWebExchange 类提供的 API。

```java
// 5、传递用户信息，即：把用户信息保存到请求头里，然后传递到下一个微服务，
String userInfo = userId.toString();
ServerWebExchange swe = exchange.mutate()
        .request(builder -> builder.header("user-info", userInfo))
        .build();

// 6、放行请求，请求会依次进入过滤器链
return chain.filter(swe);
```

测试在微服务中获取请求头中的用户信息：

```java
@GetMapping
public List<CartVO> queryMyCarts(@RequestHeader(value = "user-info", required = false) String userInfo){
    System.out.println("---- 购物车列表请求头，user-info = " + userInfo);
    return cartService.queryMyCarts();
}
```

### 步骤二、在 hm-common 中编写 SpringMVC 拦截器，获取登录用户信息
由于每个微服务都可能有获取登录用户的需求，因此直接在 `hm-common 模块` 定义拦截器获取用户信息，这样微服务只需要引入依赖即可生效，无需重复编写。

> 代码实现：`hm-common模块 ～ /interceptors/UserInfoInterceptor.java、/config/MvcConfig.java`

#### 注意：
* 1、由于 SpringMVC 拦截器在 `hm-common模块` 中，而其它模块和它不在同一个包下，其它模块中 Spring 无法扫描该拦截器，导致不生效。
解决：不同包下的配置类，如果想要被 Spring 扫描到，则需要在该包的 `src/main/resources/META-INF/` 目录下的文件中记录这些配置类，早期这个文件名字叫 `spring.factories`。

* 2、Gateway 网关模块 也是继承自 hm-common模块，当加载 SpringMVC 拦截器时会找不到其API，导致 Gateway 网关模块运行报错。
这是因为 Gateway 网关模块不属于 SpringMVC，因此需要在拦截器的配置类中添加  SpringMVC 自动装配条件注解，如下代码所示：

```java
@Configuration
@ConditionalOnClass(DispatcherServlet.class)
public class MvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 添加自定义拦截器
        registry.addInterceptor(new UserInfoInterceptor());
    }
}
```

## 4、微服务之间通过 OpenFeign 传递用户信息
微服务项目中的很多业务要多个微服务共同合作完成，而这个过程中也需要传递登录用户信息。

`OpenFeign` 中提供了一个拦截器接口 `RequestInterceptor`，所有由 `0penFeign` 发起的请求都会先调用拦截器处理请求; 
其中的 `RequestTemplate` 类中提供了一些方法可以让我们修改请求头；

在 hmall 项目我们把 `OpenFeign` 发送远程请求客户端封装在 `hm-api 模块`，因此可以把拦截器请求处理操作放在此模块，这样其它模块引入 `hm-api 模块` 就自带了拦截器，代码基本实现如下：

```java
public class DefaultFeignConfig {
    /**
     * 自定义 OpenFeign 的日志级别
     */
    @Bean
    public Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }

    /**
     * 通过定义匿名内部类的方式，添加 OpenFeign 拦截器
     * 用于在 OpenFeign 发送请求时，请求头中添加用户信息
     */
    @Bean
    public RequestInterceptor userInfoRequestInterceptor() {
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate requestTemplate) {
                Long userId = UserContext.getUser();
                if (userId != null) {
                    requestTemplate.header("user-info", userId.toString());
                }
            }
        };
    }
}
```

注意，要想使 OpenFeign 的配置类生效，需要在启用 OpenFeign 的模块中启动类上添加配置，如下代码所示：
```java
@EnableFeignClients(basePackages = "com.hmall.api.clients", defaultConfiguration = DefaultFeignConfig.class)
```



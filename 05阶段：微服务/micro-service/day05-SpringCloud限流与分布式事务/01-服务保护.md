# 一、雪崩问题
微服务调用链路中某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。

## 雪崩问题产生的原因是什么？
1. 微服务相互调用，服务提供者出现故障或阻塞；
2. 服务调用者没有做好异常处理，导致自身故障；
3. 调用链中的所有服务级联失败，导致整个集群故障；

## 解决雪崩问题的思路有哪些？
1、服务提供者尽量避免服务出现故障或阻塞。
    保证代码的健壮性；
    保证网络畅通；
    能应对较高的并发请求；

2、服务调用者要隔离被调用服务故障，避免故障传递，导致服务级联失败。

解决雪崩问题的解决方案，也叫服务保护方案。

## 服务保护方案
1. 请求限流：限制访问微服务的请求的并发量，避免服务因流量激增出现故障。
2. 线程隔离：也叫做舱壁模式，模拟船舱隔板的防水原理。通过在服务调用者中限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散。
3. 服务熔断：由 断路器 统计请求的异常比例 或 慢调用比例，如果超出阈值则会熔断该业务，则拦截该接口的请求。熔断期间，所有请求快速失败，全都走fallback逻辑。
4. 失败处理：定义 fallback 逻辑，让业务失败时不再抛出异常，而是返回默认数据或友好提示。

## 服务保护技术（常用的2种）
* Sentinel
* Hystrix

> 代码实现：`cart-service`、`hm-api`

# 二、服务保护技术 - Sentinel
Sentinel 是阿里巴巴开源的一款微服务流量控制组件。官网地址：<https://sentinelguard.io/zh-cn/>

Sentinel 客户端（即核心库、jar包）里面包含了服务保护的各种功能，只要在微服务代码中引用了该jar包，就可以在微服务代码中配置 Sentinel 提供的功能；
或者使用 Sentinel 控制台与 Sentinel 客户端进行交互。可以通过 Sentinel 控制台 监控微服务内部接口运行的情况，以及方便的配置对微服务的保护配置。

* Sentinel 控制台：<https://github.com/alibaba/Sentinel/wiki/Dashboard>

#### 簇点链路
* 簇点链路，就是单机（即单个微服务内部）调用链路。是一次请求进入服务后经过的每一个 被Sentinel监控的资源链。
* 被 Sentinel 监控的资源叫做 簇点。
* 默认 Sentinel 会监控 SpringMVC 的每一个 Endpoint(htp接口、Controller接口)。
* ⚠️ 限流、熔断等都是针对 簇点链路 中的 资源 设置的。而 资源名 默认就是接口的请求路径。

Restful 风格的API请求路径一般都相同，这会导致簇点资源名称重复。因此我们要修改 Sentinel 配置 `http-method-specify: true`，把 `请求方式+请求路径` 作为簇点资源名称

## 1、入门

如下使用 Sentinel 客户端/控制台 的方式使用 Sentinel。

### 1、在本机上启动 Sentinel 控制台
在 <https://github.com/alibaba/Sentinel/releases> 上下载 `sentinel-dashboard-1.8.6.jar`，然后通过如下命令在本机上启动 sentinel-dashboard：

```shell
# 切换到 sentinel-dashboard 存放目录下
$ cd /user/sentinel

# 运行下载的 sentinel-dashboard release 包
$ java -Dserver.port=8090 \
-Dcsp.sentinel.dashboard.server=localhost:8090 \ 
-Dproject.name=sentinel-dashboard \
-jar sentinel-dashboard-1.8.6.jar \
```

启动成功后，访问 <http://localhost:8090>，输入账号密码(sentinel) 登录 sentinel-dashboard。

### 2、在微服务中接入 Sentinel 客户端
1、在需要被监控的微服务项目添加 Sentinel 客户端依赖
```pom
<!-- Sentinel 客户端 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

2、在需要被监控的微服务项目里配置连接 Sentinel 控制台信息
```application.yml
# sentinel 控制台连接信息
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8090
      http-method-specify: true   # 开启请求方式前缀，即会把请求方式+请求路径作为 簇点资源名称
```

### 3、测试
多访问几次接入 sentinel 客户端的微服务的接口，即可在 <http://localhost:8090> 控制台 [簇点链路] 查看微服务信息。

## 2、请求限流
在 sentinel 控制台 <http://localhost:8090> 列表中，选择对应微服务的 【簇点链路】->【操作】->【流控】，即可对其做限流配置，然后在 【流控规则】中可以查看。

* QPS：QPS反映服务器在1秒内响应的请求数量，例如：QPS=100 表示每秒处理100次请求。
* 单线程QPS：单个线程每秒能处理的请求上限。例如：若线程处理一个请求需50ms，则理论最大QPS为1000ms/50ms=20。


## 3、线程隔离
当商品服务出现阻塞或故障时，调用商品服务的购物车服务也需要等待商品服务返回，购物车服务可能因此而被拖慢，甚至资源耗尽。
所以必须限制购物车服务中 查询商品这个业务 的可用线程数，实现线程隔离。

在 `sentinel` 控制台中，在会出现 `Feign` 接口的簇点资源，点击后面的`【操作】->【流控】`按钮，即可配置线程隔离:

`Feign` 接口：如购物车列表接口，需要在购物车服务中通过 FeignClient 请求商品服务。

```application.yaml
server:
  port: 8082
  tomcat:
    threads:
      max: 50   # tomcat 的最大线程数
    accept-count: 50  # 允许排队等待的线程数
    max-connections: 100  # 最大连接数
```

## 4、Fallback
在购物车服务`cart-service`中，在查询购物车列表时，需要使用 Feign 客户端查询 商品服务`item-service` 中的商品信息。如果此时商品服务响应速度非常慢，
那么在并发较高的情况下耗尽 Tomcat 资源，导致整个 购物车服务 被拖慢。

因此如上所示，通过 Sentinel 对购物车服务中的 查询购物车列表业务 做了线程隔离，避免这个业务耗尽资源。

线程隔离虽然对购物车服务起到了保护，但是存在一个问题，会导致 被隔离的业务（即查询购物车列表业务）完全不可用，接口请求报错。
为了解决这个问题，可以使用 Fallback 来友好提示用户，避免请求直接报错。

* 解决：对查询购物车列表业务中，只对 Feign 远程调用的逻辑添加 fallback，当 Feign 请求失败时走 fallback，购物车服务不会受到影响。实现步骤如下：

### 步骤一，配置 购物车微服务 将 FeignClient 作为 Sentinel 的簇点资源
```application.yaml
feign:
  okhttp:
    enabled: true
  sentinel:
    enabled: true   # 在使用 FeignClient 服务里开启 Sentinel 监控，这样 Feign 发起的资源 Sentinel 控制台可以监控到
```

### 步骤二，在 hm-api 服务中，给 FeignClient 添加 fallback 逻辑
* 方式一，FallbackClass，无法对远程调用的异常做处理
* 方式二，FallbackFactory，可以对远程调用的异常做处理（通常使用这种！）

#### 1、自定义 FallbackFactory，实现对 FeignClient 的 fallback 逻辑。

```java
/**
 * 给 ItemClient（商品FeignClient）添加 Fallback 逻辑
 */
@Slf4j
public class ItemClientFallbackFactory implements FallbackFactory<ItemClient> {
    @Override
    public ItemClient create(Throwable cause) {
        // 返回需要被 fallback 逻辑处理的 FeignClient。如果 Sentinel 监控的 Feign 资源异常了，就会走此 FeignClient 中的逻辑。
        return new ItemClient() {
            // 当商品查询失败时，走 fallback 的逻辑
            @Override
            public List<ItemDTO> queryItemByIds(Collection<Long> ids) {
                log.info("--- 查询商品失败: ", cause);
                return CollUtils.emptyList();
            }

            // 当扣减商品库存失败时，走 fallback 的逻辑
            @Override
            public void deductStock(List<OrderDetailDTO> items) {
                log.error("--- 扣减商品库存失败：: ", cause);
                throw  new RuntimeException(cause);
            }
        };
    }
}
```

#### 2、将自定义的 `FallbackFactory` 注册为一个 bean：
```java
public class DefaultFeignConfig {
    @Bean
    public ItemClientFallbackFactory itemClientFallbackFactory() {
        return new ItemClientFallbackFactory();
    }
}
```

#### 3、在对应 FeignClient 接口中指定 fallbackFactory 为自定义的 FallbackFactory：

```java
@FeignClient(value = "item-service", fallbackFactory = ItemClientFallbackFactory.class)
public interface ItemClient {
    
    @GetMapping("/items")
    List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> ids);

    @PutMapping("/items/stock/deduct")
    void deductStock(@RequestBody List<OrderDetailDTO> items);
}
```

#### 4、在 sentinel 控制台中，对 购物车服务中查询购物车列表业务 的 Feign 簇点链路添加 线程隔离，而不是对整个 购物车查询业务添加线程隔离。

## 5、服务熔断
熔断是解决雪崩问题的重要手段。思路是由 断路器 统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。
熔断该服务：是指拦截（拒绝）访问该服务的一切请求。
而当服务恢复时，断路器 会放行访问该服务的请求。

实现：在 sentinel 控制台中 簇点资源后的 【熔断】按钮，配置熔断策略。
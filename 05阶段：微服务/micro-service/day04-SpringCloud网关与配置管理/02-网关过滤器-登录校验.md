# 一、网关登录校验
问题：在 `hmall` 微服务项目中，不同的微服务负责不同的职责。登录授权 功能放在 `user-service` 微服务中，当其它服务中需要通过 token 获取到登录用户信息时，就需要做 JWT 令牌校验。
如果在其它服务中都添加 JWT 令牌校验代码，会造成代码重复、密钥泄漏的风险 等问题。

解决思路：可以把 JWT 令牌校验 放在 网关微服务中，然后把用户信息向后传递到微服务，这就需要在 网关转发请求到微服务之前做 JWT 令牌校验。

实现分析：
- 1、如何在网关转发请求之前做登录校验？ 
  - 解决：使用自定义网关过滤器，在此过滤器 `pre` 逻辑中做登录校验，并且此过滤器需在 `NettyRoutingFilter` 过滤器之前执行。
  
- 2、网关如何将用户信息传递给微服务？ 
  - 解决：在过滤器中登录校验完获取到 token 后，保存到请求头，再转发到微服务。
  
- 3、前端请求转发到对应微服务后，对应微服务需远程调用其它微服务，那么如何在微服务之间传递用户信息？ 
  - 解决：微服务之间通过 OpenFeign 发送请求时，保存用户到请求头再进行发送请求。

> 网关路由转发流程图：`/img/03-网关登录校验（重要）/01-网关请求处理流程.jpg`

## 1、网关过滤器
网关过滤器有两种，自定义这2种过滤器的过滤方法签名完全一致，即过滤器的核心方法 `filter` 完全一致。
自定义 GatewayFilter 比较麻烦，开发中通常是自定义 GlobalFilter；

### 1.1、GatewayFilter
`GatewayFilter`：路由过滤器，作用于任意指定的路由；默认不生效，需要要在 `application.yaml` 配置到路由后对配置的路由生效。
即，在 配置路由规则 中通过 `filters` 或者 ` default-filters` 属性配置的过滤器，如下配置所示，Spring 一共提供了33种。开发者也可以自定义，会比较麻烦。
```.yaml 
spring:
    gateway:
      routes:
        - id: item-service
          uri: lb://item-service
          # 使用 AddRequestHeader 过滤器，给进入 item-service 服务的所有请求添加请求头 X-Request-Color：blue
          filters:
            - AddRequestHeader=X-Request-Color, blue
      # default-filters 给网关中的每一个服务请求添加请求头： X-Truth:any will be rich
      default-filters:
        - AddRequestHeader=X-Truth, any will be rich
```

GatewayFilter 的特点：
- 可以指定作用的范围；
- 配置使用时的自定义参数；

如需自定义 `GatewayFilter` 请学习 <https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=f97692c2f656607aeb97ee92b4310d9e&p=63>

### 1.2、GlobalFilter - 常用
`GlobalFilter`：全局过滤器，作用范围是所有路由；声明后自动生效。 自定义 `GlobalFilter` 需实现 `GlobalFilter` 接口，如下代码所示：

```java
@Component
public class MyGlobalFilter implements GlobalFilter, Ordered {
    /**
     * filter 方法是过滤器逻辑的核心方法
     *
     * @param exchange 网关内部的请求上下文。包含整个过滤器链内共享数据，例如：request、response 等。所有过滤器都可以通过它存/读数据。
     * @param chain 过滤器链。当前过滤器执行完后，要调用过滤器链种的下一个过滤器。
     * @return 表示一个回调函数，等转发到服务接收请求处理完返回后，再调用该回调函数。
     */
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // TODO 模拟登录校验逻辑
        // 1、获取请求
        ServerHttpRequest request = exchange.getRequest();
        // 2、处理过滤器业务
        HttpHeaders headers = request.getHeaders();
        System.out.println("---- 网关 headers ----" + headers);
        // 3、放行请求，请求会依次进入过滤器链
        return chain.filter(exchange);

        /*
         每个网关过滤器执行过程中分为 pre 和 post 2部分逻辑。当前 filter 方法内部的所有逻辑都属于 pre 部分，filter 方法执行完后会返回 Mono 回调函数。
         微服务处理完 前端请求后，才会处理 过滤器的 post 部分，为了避免所有过滤器都阻塞时等待微服务 post 部分处理，网关采用的是非阻塞式编程，等微服务处理完后再调用 Mono 回调函数(即Post逻辑)。  
         */
    }
 
    // 返回过滤器执行优先级，值越小，优先级越高
    @Override
    public int getOrder() {
        /*
         网关在进行路由转发过程中，最后执行的一个过滤器是 NettyRoutingFilter。因此需要保证我们自定义的过滤器在 NettyRoutingFilter 之前执行。
         通过实现 Ordered 接口来指定自定义过滤器的执行顺序，getOrder 返回值越小越先执行。
         NettyRoutingFilter 的优先级为 Int 类型的最大值，此处返回 0 比它小，这样 MyGlobalFilter 会先执行。
         */
        return 0;
    }
}
```



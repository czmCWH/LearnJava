# 一、网关传递用户信息到微服务
上面通过自定义 网关过滤器 实现了登录校验功能，拿到了登录用户的信息，用户信息需向微服务传递，接下来需实现：

- 在网关拦截器中把用户信息保存到请求头，传递到下游每个微服务；

- 在微服务实现的业务中从请求头里获取用户信息；微服务的业务可能很多，可能都需要 获取请求头用户信息，如果 获取请求头用户信息的逻辑 在每个业务中都重复实现非常麻烦，可通过如下方式解决：
  - 微服务的接口都是基于 Spring MVC 实现的，在微服务中每个业务接口执行之前来获取请求头用户信息 --- `Spring MVC` 拦截器 中获取请求头用户信息，并保存到 `ThreadLocal` 中。

> 网关传递用户信息到微服务流程图：`/img/03-网关登录校验（重要）/03-网关传递信息到微服务.jpg`

## 步骤1、在 hm-gateway 网关的登录校验过滤器中，把获取到的用户信息写入请求头
需求：修改 `hm-gateway` 模块中的登录校验过滤器，在校验成功后保存用户到下游请求的请求头中。

代码实现如下所示，要修改转发到微服务的请求头，需要用到 `ServerWebExchange` 类提供的 API。

```java
@Component
@RequiredArgsConstructor
public class AuthGlobalFilter implements GlobalFilter, Ordered {
    // ...
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // ...
        
        // 5、传递用户信息，即：把用户信息保存到请求头里，转发请求到微服务，
        System.out.println("---- userId : " + userId);
        String userInfo = userId.toString();
        ServerWebExchange swe = exchange.mutate()   // mutate 表示对下游请求做更改
                .request(builder -> builder.header("user-info", userInfo))
                .build();

        // 6、放行请求，请求会依次进入过滤器链
        return chain.filter(swe);
    }
    // ...
}
```

测试在微服务中获取请求头中的用户信息：
```java
@GetMapping
public List<CartVO> queryMyCarts(@RequestHeader(value = "user-info", required = false) String userInfo){
    System.out.println("---- 购物车列表请求头，user-info = " + userInfo);
    return cartService.queryMyCarts();
}
```

## 步骤2、在 `hm-common` 中编写 SpringMVC 拦截器，获取登录用户信息
由于每个微服务都可能有获取登录用户的需求，因此直接在 `hm-common 模块` 定义通用拦截器获取用户信息，所用微服务只需要通过 `hm-common` 依赖即可生效，无需重复编写。

代码实现如下：`hm-common` -> `/interceptors/.../UserInfoInterceptor.java`
```java
/**
 * 自定义 SpringMVC 拦截器，用于获取登录用户信息保存到 ThreadLocal 中
 * 注意：次拦截器不需要做登录校验，因为登录校验放在 hm-gateway 网关里做了，请求能到此拦截器，说明校验通过了。
 */

public class UserInfoInterceptor implements HandlerInterceptor {
    /**
     * preHandle 在请求进入 Controller 之前执行
     * @param request 请求头
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1、获取登录用户信息
        String userInfo = request.getHeader("user-info");
        // 2、判断是否获取了用户信息，如果有，存入 ThreadLocal
        if (StrUtil.isNotBlank(userInfo)) {
            UserContext.setUser(Long.valueOf(userInfo));
        }
        // 3、如果没有直接放行（）
        return true;
    }

    /**
     * afterCompletion 在请求离开 Controller 之后执行，用于进行清理操作
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 清理用户信息
        UserContext.removeUser();
    }
}
```

> 代码实现：`hm-common模块 ～ /interceptors/UserInfoInterceptor.java、/config/MvcConfig.java`

### 注意：
* 1、要想自定义 SpringMVC 的拦截器生效，还需要添加实现 WebMvcConfigurer 接口的配置类；

* 2、由于 SpringMVC 拦截器在 `hm-common` 模块中，而其它模块和它不在同一个包下，其它模块中 Spring 无法扫描该拦截器，导致不生效。
  解决：需实现 `Spring Boot`自动装配。不同包下的配置类，如果想要被 Spring 扫描到，则需要在该包的 `/resources/META-INF/spring.factories` 目录下的文件中记录这些配置类，早期这个文件名字叫 `spring.factories`。

* 3、`hm-gateway` 网关模块 引用了 `hm-common` 依赖，当加载 SpringMVC 拦截器时会找不到其API，导致 Gateway 网关模块运行报错。
  因为 `hm-gateway` 不属于 `SpringMVC`，因此需要在拦截器的配置类中添加 `SpringMVC` 自动装配条件注解，如下代码所示：

```java
@Configuration
@ConditionalOnClass(DispatcherServlet.class)    // SpringMVC 自动装配条件注解，不满足条件不会加入 Bean  
public class MvcConfig implements WebMvcConfigurer {
    // 添加自定义拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new UserInfoInterceptor());
    }
}
```

```spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.hmall.common.config.MyBatisConfig,\
  com.hmall.common.config.JsonConfig,\
  com.hmall.common.config.MvcConfig
```
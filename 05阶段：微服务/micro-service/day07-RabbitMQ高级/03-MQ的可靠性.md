前面实现了消息发送者的可靠性，确保消息发送者能够把消息发送到 MQ。
但是 MQ 本身也有可能丢失消息，因此需要保证 MQ 的可靠性。

# 一、保证 MQ 的可靠性
在默认情况下，`RabbitMQ` 会将接收到的信息保存在 内存 中以降低消息收发的延迟。这样会导致两个问题：
* 一旦 `MQ` 宕机，内存中的消息会丢失；即创建的交换机、队列都会丢失。
* 内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发 MQ 阻塞；

因此需要从 `RabbitMQ` 数据存储方式入手，保证 `MQ 的可靠性`。可通过如下2种方案实现：

## 1、数据持久化
数据持久化 即把 MQ 相关数据存储到磁盘，这样就算 MQ 重启也不用担心数据丢失。RabbitMQ 实现数据持久化包括3个方面：
1. 交换机持久化；--- 在创建时指定：durability: durable，默认就是持久化
2. 队列持久化；--- 在创建时指定：durability: durable，默认就是持久化
3. 消息持久化；--- 在发送消息时指定：Delivery Mode: persistent，默认就是持久化

## 2、Lazy Queue（推荐）
如上所讲把发送给 MQ 的数据持久化以后，确保了 MQ 的可靠性。但是消息数据持久化以后，发给 MQ 的消息不仅要保存到服务器的内存，也要保存到磁盘，
这样导致每条消息处理的耗时增加，整体并发能力有所下降。`Lazy Queue` 不仅具备数据持久化，同时解决并发能力下降的问题。

从 `RabbitMQ` 的 3.6.0 版本开始就增加了 `Lazy Queue` 的概念，也就是惰性队列。惰性队列的特征如下:
* 接收到消息后直接存入磁盘，不再存储到内存；
* 消费者要消费消息时才会从磁盘中读取并加载到内存 (由于这样可能会影响消费者处理速度，MQ会动态监测消费者处理速度，可以提前缓存部分消息到内存，最多`2048`条)
* 在 `3.12` 版本后，所有队列都是 `Lazy Queue` 模式，无法更改。

要设置一个队列为惰性队列，只需要在声明队列时，指定 `x-queue-mode` 属性为 lazy 即可，代码实现有如下2种方式：
### 方式一：
```java
@Configuration
public class FanoutConfig {
    // 声明队列
    @Bean
    public Queue fanoutQueue1() {
        return QueueBuilder
                .durable("fanout.queue1")
                .lazy()     // 开启 Lazy 模式
                .build();
    }
}
```

### 方式二：
```java
@RabbitListener(queuesToDeclare = @Queue(
        name = "lazy.queue",
        durable = "true",   // 指定持久化
        arguments = @Argument(name = "x-queue-mode", value = "lazy")
))
public void listenLazyQueue(String msg){
    log.info("接收到 lazy queue 的消息: {}", msg);
}
```
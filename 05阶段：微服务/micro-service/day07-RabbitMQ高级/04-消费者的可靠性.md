# 一、消费者的可靠性
至此，`RabbitMQ` 消息收发链条中，只需解决 MQ 到 消费者的可靠性了。将从如下3个方面确保消费者的可靠性：

## 1、消费者确认机制
消费者确认机制 (`Consumer Acknowledgement`)是为了确认消费者是否成功处理消息。
当消费者处理消息结束后应该向 RabbitMQ 发送一个回执，告知 `RabbitMQ` 自己消息处理状态：
1. ack 状态：消费者成功处理消息的回执，`RabbitMQ` 从队列中删除该消息；
2. nack 状态：消费者消息处理失败的回执，`RabbitMQ` 需要再次投递消息；
3. reject 状态：消费者消息处理失败并拒绝该消息的回执，`RabbitMQ` 从队列中删除该消息；

SpringAMQP 已经实现了消息确认功能。并允许我们通过配置文件选择 `ACK`处理方式，有三种方式:
1. `none`：不处理。即消息投递给消费者后立刻 `ack`，消息会立刻从`MQ`删除。非常不安全，不建议使用。
2. `manual`：手动模式。需要自己在业务代码中调用 api，发送 `ack` 或 `reject`。存在业务入侵，但更灵活。
3. `auto`：自动模式。`SpringAMQP` 利用 `AOP` 对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回 `ack`；
当业务出现异常时，根据异常判断返回不同结果：
       如果是业务异常，会自动返回 `nack`； 
       如果是消息处理或校验异常，自动返回 `reject`；

在 消费者微服务中 配置 SpringAMQP 的消息确认功能：

```application.yml
spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto  # 关闭 none；  手动 manual；  自动模式 auto；
```

## 2、失败重试机制
如上所示，我们使用了 `auto` 方式的 消费者确认机制，如果消费者长时间无法从自身消息处理故障中恢复，这样消息无限重新投递，给 MQ服务 和 消费者服务 造成很大的压力。
对此 `SpringAMQP` 提供了 失败重试机制。

`SpringAMQP` 提供了消费者失败重试机制，在消费者出现异常时利用本地重试，而不是无限的 `requeue` 到 `mq`。
我们可以通过在 消费者服务的 `application.yaml` 文件中添加配置来开启重试机制：

```application.yaml
spring:
  rabbitmq:
    listener:
      simple:
        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息
        acknowledge-mode: auto
        # 配置消费者失败重试机制
        retry:
          enabled: true   # 开启消费者失败重试
          initial-interval: 1000ms    # 初始的失败等待时长为1秒
          multiplier: 1   # 下次失败的等待时长倍数，下次等待时长 = multiplier * initial-interval
          max-attempts: 3   # 最大重试次数
          stateless: true   # true 无状态；false 有状态。如果业务中包含事务，这里改为 false
```

### 1、失败消息处理策略
通过如上配置开启 SpringAMQP 失败重试机制后，当重试次数耗尽，如果消息依然失败，则需要有 `MessageRecoverer` 接口来处理，它包含三种不同的实现：
1. `RejectAndDontRequeueRecoverer`：重试耗尽后，直接 `reject`，丢弃消息。默认就是这种方式。会导致消息丢失，不推荐。
2. `ImmediateRequeueMessageRecoverer`：重试耗尽后，返回 `nack`，消息重新入队。
3. `RepublishMessageRecoverer`：重试耗尽后，将失败消息投递到指定的交换机

### 2、使用 RepublishMessageRecoverer 策略
* 首先，定义接收失败消息的交换机、队列及其绑定关系

* 定义 `RepublishMessageRecoverer`
```java
@Configuration
public class ErrorMessageConfiguration {

    // 声明处理 error 的交换机
    @Bean
    public DirectExchange errorExchange() {
        return new DirectExchange("error.direct");
    }

    // 声明处理 error 的队列
    @Bean
    public Queue errorQueue() {
        return new Queue("error.queue");
    }

    // 声明队列与交换机的绑定
    @Bean
    public Binding errorBinding(Queue errorQueue, DirectExchange errorExchange) {
        return BindingBuilder.bind(errorQueue).to(errorExchange).with("error");
    }

    // 实现 失败处理策略
    @Bean
    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate) {
        return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");
    }
}
```

## 3、业务幂等性
通过前面实现 MQ 可靠性、消费者可靠性 基本上能确保消息能发送到消费者，这样可能还是会出现同一个消息被消费者多次处理。例如：消费者成功处理消息成功，
此时消费者需要发送 ack 回执到 MQ，但是由于网络连接断开，回执发送失败。当消费者与 MQ 重新连接时，将会重复接收处理该消息。
为了解决同一消息被重复消费的问题，可以使用 `业务幂等性`。

幂等是一个数学概念，用函数表达式来描述是这样的:f(x)=f(f(x)。在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。

* 幂等 示例：查询业务，例如根据id查询商品；删除业务，例如根据id删除商品；
* 非幂等 示例：用户下单业务，需要扣减库存；用户退款业务，需要恢复余额；

非幂等 和 业务被重复处理原因 和 处理场景 有关，解决 非幂等 有许多方案。以下消息重复提交，导致业务重复处理为例的解决方案：

### 方案1、唯一消息ID
方案一，在 发送者 服务中给每个消息都设置一个 `唯一id`，利用 `id` 区分是否是重复消息：
1. 每一条消息都生成一个唯一的id，与消息一起投递给消费者。
2. 消费者接收到消息后处理自己的业务，业务处理成功后将消息 ID 保存到数据库。
3. 如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。

* 1、在 发送者 服务中配置发送消息时自动携带ID：
```java
@Configuration
public class MessageConfig {
        // 自定义消息转换器
       @Bean
       public MessageConverter messageConverter() {
              Jackson2JsonMessageConverter messageConverter = new Jackson2JsonMessageConverter();
              // 配置自动创建消息ID，用于识别不同的消息，也可以在业务代码中基于此ID判断是否是重复消息
              messageConverter.setCreateMessageIds(true);
              return messageConverter;
       }
}
```
* 2、在 消费者 服务中 接收消息携带的ID：
```java
@RabbitListener(queues = "simple.queue")
public void listenSimpleQueue2(Message msg) {
       log.info("监听到 simple.queue 的消息: ID = {}", msg.getMessageProperties().getMessageId());
       log.info("监听到 simple.queue 的消息: body = {}", msg.getBody());
       throw new RuntimeException("我是故意的！");
}
```

> 唯一消息ID 方案，会增加根据ID进行业务相关健壮性处理代码，造成业务侵入，另外还会影响业务本身的性能。

### 方案2、业务判断
* 结合业务逻辑，基于业务本身做判断。

1、案例：以我们的余额支付业务为例：
【支付服务】发送支付成功消息到 MQ，MQ发送消息给【交易服务】；
【交易服务】处理消息成功后，发送 ack 消息给 MQ 失败；
当用户通过【交易服务】退款成功后，【交易服务】重复接收到了 MQ 的消息，导致订单状态错误；

2、解决：【交易服务】接收到 【交易服务】支付成功消息后，先判断订单状态是否是“未支付”，如果是则修改订单状态，否则不修改。
```java
@Component
@RequiredArgsConstructor
public class PayStatusListener {

    private final IOrderService orderService;

    /*
    监听 支付成功队列消息
     */
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = "trade.pay.success.queue", durable = "true"),
            exchange = @Exchange(value = "pay.direct", type = ExchangeTypes.DIRECT),
            key = {"pay.success"}
    ))
    public void listenPaySuccess(Long orderId) {
        System.out.println("czm ---- 收到 MQ 组件消息 = " + orderId);
        // 1、查询订单
        Order order = orderService.getById(orderId);
        // 2、判断订单状态，是否为未支付
        if (order == null && order.getStatus() != 1) {
            // 不做处理
            return;
        }
        // 3、标记订单状态为已支付
        orderService.markOrderPaySuccess(orderId);
    }
}
```
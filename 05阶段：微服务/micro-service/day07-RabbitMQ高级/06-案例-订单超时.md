# 案例-订单超时

业务背景：
1. 用户下单时，`trade-service` 交易服务会 生成一个业务订单，调用 `item-service`商品微服务扣减库存、调用 `cart-service`购物车服务清理购物车；
2. 用户支付时，`pay-service` 支付服务会 生成一个支付订单，如果用户支付成功通过 异步通讯组件-RabbitMQ 发送消息;
3. `trade-service` 交易服务会监听 支付成功消息修改订单状态；

存在问题：
1. 如果用户一直不支付，那么商品将被占用无法回归库存；
2. 如果用户支付成功，但是 `trade-service` 交易服务未监听到支付消息，导致业务订单状态错误；

> 解决：在用户下单时发送延迟消息，并监听此消息（修改交易订单状态，恢复商品库存）；


## 实现步骤

* 1、用户提交订单，调用 `trade-service` 交易微服务创建订单时，发送延迟消息
```java
private final RabbitTemplate rabbitTemplate;

public Long createOrder(OrderFormDTO orderFormDTO) {

    // 5、发送延迟消息，监测订单支付状态
    rabbitTemplate.convertAndSend(
            MQConstants.DELAY_EXCHANGE_NAME,
            MQConstants.DELAY_ORDER_KEY,
            order.getId(),
            new MessagePostProcessor() {    // 通过 消息后置处理器 MessagePostProcessor 设置延迟消息
                @Override
                public Message postProcessMessage(Message message) throws AmqpException {
                    message.getMessageProperties().setDelay(10000);     // 设置延迟消息为 10秒
                    return message;
                }
            });
}
```

* 2、处理 `trade-service` 交易微服务的延迟消息 检查交易订单的状态，因此还是需要在 `trade-service` 交易微服务中监听：
```java
@Component
@RequiredArgsConstructor
public class OrderDelayMessageListener {

    private final IOrderService orderService;

    // OpenFeign 远程调用
    private final PayClient payClient;

    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = MQConstants.DELAY_ORDER_QUEUE_NAME),
            exchange = @Exchange(name = MQConstants.DELAY_EXCHANGE_NAME),
            key = MQConstants.DELAY_ORDER_KEY
    ))
    public void listenerOrderDelay(Long orderId) {
        // 1、查询订单
        Order order = orderService.getById(orderId);

        // 2、检查订单状态，判断是否已支付(收到了 `pay-service` 微服务发送的消息)
        if (order == null || order.getStatus() != 1) {
            // 订单不存 or 订单已支付
            return;
        }

        // 3、未支付，OpenFeign 远程调用 支付服务 查询支付流水状态
        PayOrderDTO payOrder = payClient.queryPayOrderByBizOrderNo(orderId);
        if (payOrder != null && payOrder.getStatus() == 3) {
            // 4.1、已支付，标记订单状态为已支付
            orderService.markOrderPaySuccess(orderId);
        } else {
            // 4.1、未支付，取消订单，恢复库存
            orderService.cancelOrder(orderId);
        }
    }
}
```

* 3、在 `hm-api` 微服务中，实现远程调用 根据 `交易订单ID` 来查询 `支付订单` 信息

当出现了不可抗因素时，导致 MQ 异步消息通知无法成功。那么有什么方案兜底。

# 一、延迟消息（可靠性兜底方案）
延迟消息：发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。
延迟任务：设置在一定时间之后才执行的任务。

> RabbitMQ 默认不支持延迟消息，以下 2种 延迟消息实现方案 都是基于 MQ 的功能拓展来模拟延迟消息的效果：

## 1、死信交换机
当一个队列中的消息满足下列情况之一时，就会成为 `死信(dead letter)`：
1. 消费者使用 `basic.reject` 或 `basic.nack` 声明消费失败，并且消息的 `requeue` 参数设置为 `false`。
2. 消息是一个过期消息(达到了队列 或 消息本身设置的 过期时间)，超时无人消费。
3. 要投递的队列消息堆积满了，最早的消息可能成为死信。

一个消息如果成为了死信，默认会被销毁。为了避免死信被销毁，需把它投递到交换机中。

如果队列通过 `dead-letter-exchange` 属性指定了一个交换机，那么该队列中的`死信`就会投递到这个交换机中。
这个交换机称为 `死信交换机`(`Dead Letter Exchange`，简称`DLX`)。


### 步骤1，发送者 发送延迟 10 秒的消息
```java
@Autowired
private RabbitTemplate rabbitTemplate;

@Test
void testSendDelayMessage() {
    rabbitTemplate.convertAndSend("normal.direct", "hi", "hello，你好！", new MessagePostProcessor() {
        @Override
        public Message postProcessMessage(Message message) throws AmqpException {
            message.getMessageProperties().setExpiration("10000");  // 设置消息过期时间 10秒
            return message;
        }
    });
}
```

### 步骤2，消费者 声明接收消息交换机及其绑定的队列，并给该队列绑定死信交换机
```java
public class NormalConfiguration {
    // 声明 交换机(normal.direct)
    @Bean
    public DirectExchange normalExchange() {
        return new DirectExchange("normal.direct");
    }

    // 声明 队列(normal.queue)，并绑定 死信交换机(dlx.direct)
    @Bean
    public Queue normalQueue() {
//        return new Queue("normal.queue");
        return QueueBuilder
                .durable("normal.queue")
                .deadLetterExchange("dlx.direct")
                .build();
    }

    // 声明 交换机(normal.direct) 绑定 队列(normal.queue)
    @Bean
    public Binding normalExchangeBinding(Queue normalQueue, DirectExchange normalExchange) {
        return BindingBuilder.bind(normalQueue).to(normalExchange).with("hi");
    }
}
```

> 由于没有给 发送者发送消息的交换机及队列 添加监听，所以该消息无人消费，过期后成为死信。
> 如下，接收死信交换机中的消息，即可达到延时消息的效果。

### 步骤3，消费者 声明监听 死信交换机中的消息
```java
@RabbitListener(bindings = @QueueBinding(
        value = @Queue(name = "dlx.queue", durable = "true"),
        exchange = @Exchange(name = "dlx.direct", type = ExchangeTypes.DIRECT),
        key = {"hi"}
))
public void listenDlxQueue(String msg){
    log.info("--- 消费者监听到消息 dlx.queue 队列的消息：{}", msg);
}
```

## 2、延迟消息插件
基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此 RabbitMQ 社区提供了一个延迟消息插件来实现相同的效果。
这个插件可以将普通交换机改造为支持延迟消息功能的交换机，当消息投递到交换机后可以暂存一定时间，到期后再投递到队列。

### 步骤1，下载 RabbitMQ 插件
可在 RabbitMQ 社区插件 <https://www.rabbitmq.com/community-plugins> 上下载 `rabbitmq_delayed_message_exchange` 插件。
我们安装 RabbitMQ 的版本为 3.13.7-management，因此插件版本最好与之保持一致，因此下载 `rabbitmq_delayed_message_exchange-3.13.0.ez`。
注意插件需下载 `.ez` 安装包文件。<https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases>

### 步骤2，安装 RabbitMQ 插件

回顾我们安装 RabbitMQ 的命令，指定了 数据卷 挂载到了其插件目录：
```shell
$ docker run \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=admin \
-v mq-plugins:/plugins \    # 把 mq-plugins 数据卷挂载到了 mq 容器的 /plugins 目录
--name mq \
--hostname mq \
-p 15672:15672 \
-p 5672:5672 \
--network hm-net \
-d \
rabbitmq:3.13.7-management
```

```shell
# 1、查看 RabbitMQ 插件目录对应的数据卷
$ docker volume inspect mq-plugins
[
    {
        "CreatedAt": "2025-07-31T02:46:30Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/mq-plugins/_data",
        "Name": "mq-plugins",
        "Options": null,
        "Scope": "local"
    }
]

# 如上显示的 /var/lib/docker/volumes/mq-plugins/_data 这个目录是 Docker 内部管理的隐藏路径，不会直接显示在 Finder 中，Mac 中无法直接访问。

# 2、通过 docker 命令吧把下载的 RabbitMQ 插件复制到 RabbitMQ 插件目录下
$ docker cp /Users/chen/Desktop/rabbitmq_delayed_message_exchange-3.13.0.ez mq:/plugins

# 3、执行如下命令，启用并安装插件
$ docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange
Enabling plugins on node rabbit@mq:
rabbitmq_delayed_message_exchange
The following plugins have been configured:
  rabbitmq_delayed_message_exchange
  rabbitmq_federation
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_prometheus
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@mq...
The following plugins have been enabled:
  rabbitmq_delayed_message_exchange

started 1 plugins.
```

### 步骤3，使用 RabbitMQ 延迟插件

1、消费端实现监听延迟消息：

```java
@Slf4j
@Component
public class SpringRabbitListener {
    /**
     * 通过 RabbitMQ 插件监听延迟消息
     */
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = "delay.queue", durable = "true"),
            exchange = @Exchange(name = "delay.direct", type = ExchangeTypes.DIRECT, delayed = "true"),     // 必须设置 delayed = "true"
            key = {"hi"}
    ))
    public void listenDelayQueue(String msg){
        log.info("--- 消费者监听到消息 delay.queue 队列的消息：{}", msg);
    }
}
```

2、发送端发送延迟10秒的消息：
```java
@Autowired
private RabbitTemplate rabbitTemplate;

@Test
void testSendDelayMessageByPlugin() {
    // 使用消息后置处理器 MessagePostProcessor 添加消息头
    rabbitTemplate.convertAndSend("delay.direct", "hi", "你好！插件延迟消息", new MessagePostProcessor() {
        @Override
        public Message postProcessMessage(Message message) throws AmqpException {
            message.getMessageProperties().setDelay(10000);  // 发送延迟消息，setDelay 设置消息延迟 10 秒
            return message;
        }
    });
}
```

#### 注意⚠️
这种延迟消息的实现，是在 RabbitMQ 内部添加依赖于 CPU 时钟计时实现，它是一个 CPU 密集型任务。因此如果同一时刻在 MQ 内部有大量的延迟消息需要计时，
这会给 CPU 造成很大的压力，使用 RabbitMQ 延迟消息时应避免同一时刻在MQ内部存在大量延迟消息。
因此需要尽可能缩短延迟时间，延迟时间越长累计的延迟消息越多，造成CPU压力过大。如果延迟消息时间长，但是业务并发低，也没关系。


`Redis` 经常被用作缓存，日常开发中把查询数据库的数据放在 `Redis` 中缓存一份，后续查询就直接走 `Redis`，从而提高查询性能。
而缓存在使用的过程中存在很多问题需要解决，如下介绍所示：

# 一、Redis 缓存数据一致性问题
Redis 缓存数据一致性问题，是指 Redis 缓存中的数据与数据库中不一致。

## 目前企业用的最多的 Redis 缓存模型：

- 1、Cache Aside Pattern（常用方案）
  - 由业务开发者，在更新数据库的同时更新缓存。
  - 特点：业务代码侵入；数据一致性高。

- 2、Read/Write Through Pattern
  - 缓存与数据库整合为一个服务，由服务来维护一致性。业务开发者直接调用该服务接口，无需关心缓存一致性问题。
  - 特点：开发成本高。

- 3、Write Behind Caching Pattern
  - 增删改查业务直接基于缓存，由其它线程异步的将缓存数据持久化到数据库，保证最终一致。
  - 特点：高性能；实现流程比较复杂，弱一致性（最终一致性）。


## 缓存一致性策略的最佳实践方案

* 低一致性需求：使用 `Redis` 的 `key` 过期清理方案； 

* 高一致性需求：主动更新，并以超时剔除作为兜底方案，具体实现如下：
  - 读操作：
    - 缓存命中则直接返回；
    - 缓存未命中则查询数据库，并写入缓存，设定超时时间；
  - 写操作：
    - 先写数据库，然后再删除缓存； 
    - 要确保数据库与缓存操作的原子性；

# 二、缓存穿透问题
* 场景：当请求查询 Redis 缓存未命中时，需要查询数据库以加载缓存。如果访问的数据库中也不存在的数据，因此不管请求该数据多少次，缓存永远不可能建立，请求永远会直达数据库。
* 问题：假如有不怀好意的人，开启很多线程频繁的访问一个数据库中也不存在的数据。由于缓存不可能生效，那么所有的请求都访问数据库，可能就会导致数据库因过高的压力而宕机。

- 缓存穿透问题：是指客户端请求的数据在数据库中根本不存在，从而导致请求穿透 Redis 缓存，直接打到数据库的问题。

## Redis 缓存穿透解决方案：
- 1、缓存空对象：当请求的到数据库中不存的数据时，以该请求参数为 key 在 Redis 中缓存一个空对象，并设置TTL，后续查询直接返回空对象，避免频繁查询数据库。
  - 优点：实现简单，维护方便；
  - 缺点：额外的内存消耗；

- 2、布隆过滤器：
  - 优点：内存占用较少，没有多余的key；
  - 缺点：存在误判可能；

### 布隆过滤器
布隆过滤是一种数据统计的算法，用于检索一个元素是否存在一个集合中。但是布隆过滤无需存储元素到集合，而是把元素映射到一个很长的二级制数位上。
* 首先需要一个很长很长的二级制数，默认每一位都是0；
* 然后需要N个不同算法的哈希函数；
* 预处理，将集合中的元素根据N个哈希函数做运算，得到N个数字，然后将每个数字对应的bit位标记为1；
* 请求时，要判断某个元素是否存在，只需要把元素按照上述方式运算，判断对应的bit位是否是1即可；


# 三、缓存雪崩问题
`Redis` 缓存雪崩问题：是指在 同一时段大量的缓存`key`同时失效 或者 `Redis`服务宕机，导致大量请求到达数据库，带来巨大压力。

常见的解决方案有：
- 给不同的 `Key` 的 `TTL`(过期时间) 添加随机值，这样 `KEY` 的过期时间不同，不会大量`KEY`同时过期；
- 利用 `Redis` 集群 提高服务的可用性，避免缓存服务宕机；
- 给缓存业务添加降级限流策略；
  - 避免 Redis缓存服务宕机时，数据库压力过大，等缓存服务恢复，再解除限流策略。
- 给业务添加多级缓存；
  - 比如先查询本地缓存（如：web浏览器本地缓存、nginx 缓存），本地缓存未命中再查询`Redis`，`Redis`未命中再查询数据库。即便 `Redis` 宕机，也还有本地缓存可以抗压力；

# 四、缓存击穿问题
`Redis` 缓存击穿问题，也叫 `热点Key问题`，就是一个 `被高并发访问` 并且 `缓存重建业务较复杂` 的 `key` 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

通常 Redis 缓存采用的是`Cache Aside`模式，当缓存失效时需要下次查询时才会更新缓存。当某个key缓存失效时，需要重新从数据库查询写入 redis。
但是从数据库中查询并构建数据过程比较复杂，需要查询多张表，以及其它运算，最终得到查询结果混存到 redis。这样，此业务耗时比较长。在这一段时间内，  
如果这个key是热点key，并发访问量比较高。就会在一瞬间涌入大量请求，都发现缓存未命中，于是都会去查询数据库，尝试重建缓存。可能一瞬间就把数据库压垮了。

常见的解决方案有两种：

- 互斥锁：给重建缓存逻辑加锁，避免多线程同时指向
- 逻辑过期：热点key不要设置过期时间，在活动结束后手动删除。
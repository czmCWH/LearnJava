# 延迟消息的应用 - 案例订单超时

- 业务背景：
  1. 用户下单时，`trade-service` 交易服务会 生成一个业务订单，调用 `item-service`商品微服务扣减库存、调用 `cart-service`购物车服务清理购物车，此时交易订单创建成功；
  2. 用户支付时，`pay-service` 支付服务会 生成一个支付订单，如果用户支付成功通过 异步通讯组件-RabbitMQ 发送消息;
  3. `trade-service` 交易服务会监听 支付成功消息修改订单状态；

- 存在问题：
  1. 如果用户一直不支付，那么商品将被占用无法回归库存；
  2. 如果用户支付成功，但是 `trade-service` 交易服务未监听到支付消息，导致业务订单状态错误；

- 解决思路：在用户调用 `trade-service` 下单时发送延迟消息，并在 `trade-service` 监听此消息（修改交易订单状态，恢复商品库存），流程见图 `/img/06-案例-订单超时实现流程.jpg`


## 实现步骤

代码实现：`0/day07/02-hmall/trade-service/.../service/impl/OrderServiceImpl.java`

### 步骤1、用户提交订单，调用 `trade-service` 交易微服务创建订单时，发送延迟消息
```java
private final RabbitTemplate rabbitTemplate;

public Long createOrder(OrderFormDTO orderFormDTO) {

    // 5、发送延迟消息，监测订单支付状态
    rabbitTemplate.convertAndSend(
            MQConstants.DELAY_EXCHANGE_NAME,
            MQConstants.DELAY_ORDER_KEY,
            order.getId(),
            new MessagePostProcessor() {    // 通过 消息后置处理器 MessagePostProcessor 设置延迟消息
                @Override
                public Message postProcessMessage(Message message) throws AmqpException {
                    message.getMessageProperties().setDelay(10000);     // 设置延迟消息为 10秒
                    return message;
                }
            });
}
```

### 步骤2、处理 `trade-service` 交易微服务的延迟消息 检查交易订单的状态，因此还是需要在 `trade-service` 交易微服务中监听：
```java
@Component
@RequiredArgsConstructor
public class OrderDelayMessageListener {

    private final IOrderService orderService;

    // OpenFeign 远程调用
    private final PayClient payClient;

    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = MQConstants.DELAY_ORDER_QUEUE_NAME),
            exchange = @Exchange(name = MQConstants.DELAY_EXCHANGE_NAME),
            key = MQConstants.DELAY_ORDER_KEY
    ))
    public void listenerOrderDelay(Long orderId) {
        // 1、查询订单
        Order order = orderService.getById(orderId);

        // 2、检查订单状态，判断是否已支付(收到了 `pay-service` 微服务发送的消息)
        if (order == null || order.getStatus() != 1) {
            // 订单不存 or 订单已支付
            return;
        }

        // 3、未支付，OpenFeign 远程调用 支付服务 查询支付流水状态
        PayOrderDTO payOrder = payClient.queryPayOrderByBizOrderNo(orderId);
        if (payOrder != null && payOrder.getStatus() == 3) {    // 已支付
            // 4.1、已支付，标记订单状态为已支付
            orderService.markOrderPaySuccess(orderId);
        } else {
            // 4.1、未支付，取消订单，恢复商品库存
            orderService.cancelOrder(orderId);
        }
    }
}
```

### 步骤3、在 `hm-api` 微服务中，实现远程调用 根据 `交易订单ID` 来查询 `支付订单` 信息
```java
/**
 * FeignClient远程调用 - 根据 交易订单ID 查询 支付订单流水
 */

@FeignClient(value = "pay-service", fallbackFactory = PayClientFallback.class)
public interface PayClient {
    /**
     * 根据交易订单id查询支付单
     *
     * @param id 业务订单id
     * @return 支付单信息
     */
    @GetMapping("/pay-orders/biz/{id}")
    PayOrderDTO queryPayOrderByBizOrderNo(@PathVariable("id") Long id);
}
```

```java
/**
 * 查询支付订单失败的逻辑
 */

@Slf4j
public class PayClientFallback implements FallbackFactory<PayClient> {
    @Override
    public PayClient create(Throwable cause) {
        return new PayClient() {
            @Override
            public PayOrderDTO queryPayOrderByBizOrderNo(Long id) {
                return null;
            }
        };
    }
}
```

### 步骤4、测试，注释支付服务中支付成功通知，
如下注释 `pay-service` 服务中的支付消息通知，然后在购买商品测试，查看支付成功等待10秒后，订单服务中订单状态是否更新。
```java
public class PayOrderServiceImpl {
    public void tryPayOrderByBalance(PayOrderFormDTO payOrderFormDTO) {
        // 2、更改为 异步通讯组件-RabbitMQ 发送消息
        // 注释消息测试
//        try {
//            rabbitTemplate.convertAndSend("pay.direct", "pay.success", po.getBizOrderNo());
//        } catch (Exception e) {
//            log.error("--- 发送支付状态通知失败，订单ID={}", po.getBizOrderNo(), e);
//        }
    }
}
```
# 一、自定义 SQL（使用较少）
概念：我们可以利用 MP 的 Wrapper 来构建复杂的 Where 条件，然后自己定义 SQL 语句中剩下的部分。

- 自定义 SQL 实现步骤： 
  1. 在 Service 层基于 Wrapper 构建 where 条件；
  2. 调用 Mapper 层自定义的方法并传递 Wrapper 参数；
     - Wrapper 参数需使用 `@Param("ew")` 注解，必须是 `ew`
  3. 在自定义SQL中使用传递的 Wrapper 条件；
     - 自定义的SQL书写在 Mapper 的自定义方法上 或 XML 文件中；
     - 在自定义 SQL 中使用 `${ew.customSqlSegment}` 传递的 Wrapper 条件。


# 二、案例 - 更新 id 为 1,2,4 的用户余额扣 200
SQL实现：`update user set balance = balance - 200 where id in (1,2,4)`

## 方案1、直接在 wrapper 中添加非 where 条件的 sql
```java
@Autowired
UserPlusMapper userPlusMapper;

UpdateWrapper<User> wrapper = new UpdateWrapper<>();
// 1、自定义更新的语句
// ⚠️：wrapper 是在 Service 业务层使用的，如下将sql语句的一部分写在了业务层。这在项目开发规范中是不允许的，因为不便于后续维护，SQL语句只能定义在 Mapper 中。
// 解决办法：通过 MP 自定义SQL
wrapper.setSql("balance = balance - 200");

// 2、设置 where 条件语句
wrapper.in("id", 1,2,4);

// 3、执行更新
userPlusMapper.update(wrapper);
```
 
## 方案2、使用 MP 自定义SQL 实现
完整代码实现：`/test/.../WrapperTest.java -> testCustomSqlSegment()`

- Service 层：
```java
// 1、创建条件构造器
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
// 2、设置 where 条件语句
wrapper.in(User::getId, 1,2,4);
userPlusMapper.updateBalanceByWrapper(200, wrapper);
```

- Mapper 层：
```java
public interface UserPlusMapper extends BaseMapper<User> {
    /**
     * MyBatis-Plus 自定义 SQL
     * @Param("ew")、${ew.customSqlSegment} 都是固定写法
     */
    @Update("update user set balance = balance - #{amount} ${ew.customSqlSegment}")
    void updateBalanceByWrapper(@Param("amount") int amount, @Param("ew") LambdaQueryWrapper<User> wrapper);
}
```

# 三、总结
为什么把复杂的 where 条件写在 Service 层，而把剩余的 Sql 语句写在 mapper 层？
因为 where 条件是和业务相关的， Service 层尽量不能涉及到表字段的指定；而剩余的 Sql 写在 `mapper层` 或 `xml 文件` 中交给 mapper 处理。



# 一、分页插件
MyBatis-Plus 内置了分页插件，是基于 拦截器 通过对 `select` sql语句拦截来实现的分页查询功能。
同时，MP 提供了许多内置拦截器，具体见：`笔记/img/04-MP拦截器.jpg`

## 1、分页插件基本使用

* 步骤1，声明配置类，注册 MyBatis-Plus 的分页插件，代码见： `src/.../config/MybatisConfig.java`
```java
@Configuration
public class MybatisConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        // 1、初始化核心插件，用于添加 MP 提供的插件
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 2、添加 MyBatis-Plus 的 分页拦截器 插件
        PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); // 指定数据库方言为 DbType.MYSQL
        pageInterceptor.setMaxLimit(1000L); // 设置分页上限，每次最多查询1000条
        interceptor.addInnerInterceptor(pageInterceptor);
        // 还可以继续添加 MP 的其它插件..
        return interceptor;
    }
}
```

* 步骤2，直接使用 MyBatis-Plus 的 IService、BaseMapper 的分页API，如：page 方法，Lambda query 。代码见：：`src/test/.../UserServiceTest.java`

```java
@Test
public void testPage() {
    // 1、准备分页条件
    // 1.1、分页条件
    int pageNo = 1, pageSize = 10;  // 当前页码(从1开始)、每页条数
    Page<User> page = Page.of(pageNo, pageSize);

    // 1.2、排序条件
    page.addOrder(OrderItem.desc("createTime"));    // 根据时间降序
    page.addOrder(OrderItem.asc("balance"));    // 根据balance升序

    // 2、分页查询
    Page<User> userPage = userService.page(page, null);

    // 3、解析查询结果
    long pages = userPage.getPages();
    long total = userPage.getTotal();
    System.out.println("--- 总页数 = " + pages);
    System.out.println("--- 总记录数 =" + total);

    List<User> users = userPage.getRecords();
    users.forEach(System.out::println);
}
// 1、IService 的 page 方法
@Test
public void testPage() {
    // 1、创建一个分页对象
    // 参数1：当前页码，从1开始
    // 参数2：每页条数
    Page<User> page = new Page<>(3, 2);     // 每页查询2条，查询第3页的数据

    // 2、分页查询
    Page<User> userPage = userService.page(page, null);

    System.out.println("--- 总页数 = " + userPage.getPages());
    System.out.println("--- 总记录数 =" + userPage.getTotal());
    for (User user : userPage.getRecords()) {
        System.out.println(user);
    }
}
```

# 二、案例1 - 简单的带过滤条件的分页查询
- 需求：遵循下面的接口规范，编写一个UserController接口，实现User的分页查询
  - 请求方式：GET
  - 请求路径：/users/page
  - 请求参数：pageNo、pageSize、sortBy、isAsc、name、status
  - 说明：如果 sortBy 排序字段为空，默认按照更新时间排序；排序字段不为空，则按照排序字段排序。
  - 返回结果：
    ```json
    {
      "total": null,
       "pages": null,
       "list": []
    }
    ```
- 代码实现：`PageQuery.java UserQuery.java`、`PageDTO.java`、`UserController.java -> queryUsersPage`

```java
@Override
public PageDTO<UserVO> queryUsersPage(UserQuery query) {
    // 1.1、获取查询条件
    String name = query.getName();
    Integer status = query.getStatus();

    // 1.2、构建分页条件
    Page<User> page = Page.of(query.getPageNo(), query.getPageSize());

    // 1.3、排序条件
    if (StrUtil.isNotBlank(query.getSortBy())) {
        page.addOrder((new OrderItem()).setColumn(query.getSortBy()).setAsc(query.getIsAsc()));
    } else {
        // 默认按照更新时间排序
        page.addOrder(OrderItem.desc("update_time"));
    }

    // 2、分页查询
    Page<User> p = lambdaQuery()
            .like(name != null, User::getUsername, name)
            .eq(status != null, User::getStatus, status)
            .page(page);

    // 3、封装 VO 结果
    PageDTO<UserVO> pageDTO = new PageDTO<>();
    // 总页数
    pageDTO.setPages(p.getPages());
    // 总条数
    pageDTO.setTotal(p.getTotal());
    // 查询记录数组
    List<User> records = p.getRecords();
    if (CollUtil.isEmpty(records)) {
        pageDTO.setList(Collections.emptyList());
        return pageDTO;
    }
    // 拷贝user的vo
    List<UserVO> vos = BeanUtil.copyToList(records, UserVO.class);
    pageDTO.setList(vos);
    // 4、返回
    return pageDTO;
}
```

## 案例优化：封装通用分页实体
- 需求：
  1. 在 PageQuery 中定义方法，将 PageQuery 对象转为 MyBatisPlus 中的 Page 对象。
  2. 在 PageDTO 中定义方法，将 MyBatisPlus 中的 Page 结果转为 PageDT O结果。

- 代码实现：
  - `PageQuery.java`，统一封装实例方法 toMpPage 把查询实体类转换为 MyBatis-Plus 分页条件对象 `Page`。
  - `PageDTO.java`，统一封装静态方法，将 MybatisPlus 分页结果转为 VO 分页结果
  - `UserServiceImpl.java -> queryUsersPage`，
